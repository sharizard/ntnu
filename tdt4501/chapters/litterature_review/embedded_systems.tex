\section{Embedded systems}
Embedded software er en slags programvare for innebygde systemer. Disse programvarene er spesialisert for en type hardware (som den ligger og kjører på). Disse programvarene har derfor spesifikke begrensninger når det kommer til run-time, som minnebruk, prosesseringskraft osv.

ES har en store rolle idag siden embedded systems utvikles stadig, spesielt med IoT som en trend nå.

Problem: Har en lang livsstid som gjør det utfordrenede å vedlikeholde gamle systemer kontra utviling av nye. Bedrifter må derfor vedlikeholde mange ulike konfigurasjoner, og vedlikeholde systemer er noe av det mest utfordrende siden det krever så mye tid. Derfor er det viktig å se på løsninger som tar til hensyn til dette. Utvikle abstrakte, high level design tme quality software. Viktig med arkitektur. Problem er at de fleste foretrekker å levere noe i tide enn å lage noe bra.

Trenger en platform for å kunne vedlikeholde TG kontinuerlig, veilede, prioritere, håndtere, refactor.


...............

Most of the future computing systems will be embedde systems. Such systems will integrate both hardware and software components\cite{wolfmadsen-2000}. Embedded software are specialized hardware it runs on, which gives us some constraints when it comes to run-time, like memory usage, processessing power etc. With Internet of Things as a big trend now, these types of software has a big role today. 

One of the problems ES faces is the 

\subsection{Virtualization of embedded systems}


\subsection{Configuration management}
Configuration management er et disiplin for styring av av innhold, endringer, status på delt informasjon i et prosjekt. Det omfatter både prosesser og tekniske løsninger for å håndtere endringer og integriteten til prosjektet.F.eks hvis man utgir ny versjon av et produkt, må dokumentasjon også oppdateres. Config Management identifiserer hver komponent, og holder rede på alt som har blitt foreslått og godkjent endring fra dag 1 til slutt.

Software CM er en disiplin for kontrollering av programvaresystemer. Altså kontrollere utviklingen av store og komplekse programvarer. Noen eksempler på SCM er Git-Scm, SVN, RCS, Adele, ClearCase osv. Versjonskontroll er nøkkelen bak SCM. Følgende aspekter er med å definere CM ifølge IEEE:
-	Identification: Struktur av produktet, identifiserer komponenter og deres typer, gjør den unik og tilgjengelig på en måte.
-	Control: Kontrollerer release og og endringer av et produkt i løpet av produktets livsyklus ved å ha diverse kontroller/sjekk som sørger for konsistent produkt via "creation of a baseline product"
-	Status Accounting: Tar opp og rapporterer status til komponenter og evt endringer (forespørsler). Får også  statistikk om produktet.
-	Audit and Review: Validerer det komplette produktet og vedlikeholder konsistensen mellom komponenter ved å sørge for at produktet er en vel-definert kolleksjon av komponenter.

Kan utvides med disse tre definisjonene å:
-	Manufacture: Vedlikeholde konstruksjon og bygge produktet på en optimert måte. 
-	Process management: Passe på organisasjonens personvern, prosedyrer og livssyklus modell.
-	Teamwork: Sjekke arbeidet og passe på et godt samarbeid, og passe på interaksjonen mellom flere brukere og produktet.

shNår skal CM brukes? Det varierer. Noen velger å bruke CM system når produktet har gått gjennom utviklingsfasen og er klar for lansering/shipment. Andre velger å putte alt i CM ved oppstart av prosjektet. Begge har sine overheads. Man kan ta et valgt basert på overheads ved en endring. Er det mye manuell arbeid som å fylle ut diverse former, søke om godkjennelse osv vil man ofte plassere programverer under CM etter utvikling. Men hvis en forespørslen om en endring bruker lite tid og innsats fra utviklere, kan man velge å implementere tidlig. I teorien kan CM implementeres i alle stadiger i produktets livssyklus som opprettelse, utvikling, release, levering til kunde, bruk av produkt osv. Men ideelt sett bør et CM ha lite overhead som mulig, slik at software til CM implementeres så tidlig som mulig. Eksisterende CM systemer fokusterer dessverre på en viss fase i livsfasen, så brukere er begrenset av funksjonaliteten.



Ved å velge en robust SCM system gjør det oss mulige til å håndtere store og komplekse filmengder, støtter distribuert utvikling. En riktig kombinasjon av SCM system og "best practices" gjør det mulig for embedded development projects i å progressere raskt og effektivt.


Noen utfordringer med utvikling av embedded systemer er følgende:
-	Complex file sets
o	En embedded system består av flere komponenter, både hardware og software. Dette gjør systemet komplekst siden et slikt system kan ha mange varierte komponenter. Systemer kan også ha ulike varianter av komponenter til en spesifikk platform slik at man kan selge t produkt ved å endre ltit på krav. Å håndtere disse variantene er en stor utfordring. En annen utfordring er at produkter krever en korrekt versjon av en komponent. Å sørge for at korrelasjonen mellom hver komponent og deres avhengige filer er vedlikeholdt er en utfordring det å.
-	Distributed teams
o	Komponenter kan utvikles i ulike steder i vår verden. Samtidig kan to teams to forskjjelige steder jobbe med samme komponent, spesielt når noe outsources. Slikt samarbeid krever at utviklere har adgang til hver andres arbeid. Utfordringen er at utviklere som jobber i hvert sitt sted (geografisk) holder seg synkronisert.
-	Management and versioning of intellectual property
o	Siden embedded systemer ofte tar I bruk tredje-parts teknologier, er det viktig at de utviklerne bak disse teknologiene oppdater og vedlikeholder arbeidet sitt. Disse oppdateringene må også være sporbare slik at prosjektet inneholder riktig, kompatibel og stabil versjon av teknologien. Utfordringen er å tillate disse utviklerne å sjekke inn contributions og spore endringer i det man har kontribuert. Velge man noe open source ervel dette ikke et problem?




Når det kommer til teknisk gjeld er det ikke alltid personen som har utviklet noe som tar ansvar, men kan en annen kan ta seg av den gjelda. Mange utviklere vedlikeholder ikke sin egen kode. Mange selskaper har også regler om at når et software er ferdig utviklet av de "beste" til å bli vedlikeholdt av de nest beste, som ofte kan få mindre betalt men har mye mer arbeid å gjøre. Ingen i din organisasjonen viser interesse for det, er brukerne som må betale for gjelda. Utviklere er belønnet for hvor raskt de implementerer enn langsiktig vedlikehold og kan ha fått seg et nytt prosjekt før gjelda er betalt. Få systemer har TODO eller FIXME kommentarer i kildekoden. 

Til forskjell fra finansiell gjeld kan teknisk gjeld aldri betales tilbake i sitt fulle. Å betale TG kommer i en form av hvor lang tid det tar å fikse koden/problemet. Men det er ikke lett å vise hvilke gjeld som har høyest kost. Er interessen lavere enn hva det koster, er det ikke vits i å betale tilbake. Eksempel: Man har et system som trenger en oppgradering som kan koste 1 million. Man tar valget i å ikke oppgradere, og satse på at systemet fungerer. Det gjør det ikke, systemet går ned og firmaet taper felre millioner på å reparere systemet. Her kunne man spart penger på å oppgradere.


\subsection{Software reuse}
Use of existing software artifacts, or knowledge, to create software, is a key method for improving software quality.

\subsection{Software development life cycles} % (fold)
Weathered j-pop tube paranoid systema marketing sprawl warehouse boy receding corrupted footage DIY order-flow Chiba. Rain narrative construct shoes kanji faded bicycle denim girl. Gang car city sentient silent drugs dolphin man. Garage lights face forwards motion monofilament stimulate table sensory network disposable cartel systema sign katana. Man apophenia pre-A.I. papier-mache pistol range-rover rain computer receding hacker saturation point. 

\subsection{Software evolution} % (fold)
Soul-delay shoes neural wonton soup hotdog BASE jump knife towards A.I. engine concrete katana network bridge cartel artisanal. Rain girl shanty town advert into uplink pre-convenience store camera singularity DIY marketing Tokyo papier-mache j-pop nodal point. Fluidity hotdog camera cyber-assassin bomb 8-bit denim concrete shoes. A.I. weathered nodality corporation voodoo god industrial grade soul-delay jeans 8-bit. 

\subsection{Deployment} % (fold)
Systema beef noodles rifle papier-mache wristwatch Legba futurity city meta-Kowloon. Tattoo film otaku carbon sprawl bomb vehicle boat refrigerator San Francisco woman grenade meta-tube neural digital. Courier uplink chrome convenience store marketing Chiba refrigerator smart-modem 8-bit. Post-skyscraper claymore mine towards Kowloon hotdog savant rebar camera. Dead jeans weathered neural carbon paranoid gang A.I. nano-office papier-mache youtube 8-bit corrupted. Weathered paranoid cardboard tiger-team 3D-printed kanji man savant faded footage rebar. Man smart-denim convenience store pre-towards kanji nano-hacker soul-delay woman dome physical. 
