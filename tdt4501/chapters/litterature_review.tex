\part{Second part}
\chapter{Litterature review}

\section{Embedded systems}
Embedded software er en slags programvare for innebygde systemer. Disse programvarene er spesialisert for en type hardware (som den ligger og kjører på). Disse programvarene har derfor spesifikke begrensninger når det kommer til run-time, som minnebruk, prosesseringskraft osv.

ES har en store rolle idag siden embedded systems utvikles stadig, spesielt med IoT som en trend nå.

Problem: Har en lang livsstid som gjør det utfordrenede å vedlikeholde gamle systemer kontra utviling av nye. Bedrifter må derfor vedlikeholde mange ulike konfigurasjoner, og vedlikeholde systemer er noe av det mest utfordrende siden det krever så mye tid. Derfor er det viktig å se på løsninger som tar til hensyn til dette. Utvikle abstrakte, high level design tme quality software. Viktig med arkitektur. Problem er at de fleste foretrekker å levere noe i tide enn å lage noe bra.

Trenger en platform for å kunne vedlikeholde TG kontinuerlig, veilede, prioritere, håndtere, refactor.


...............

Most of the future computing systems will be embedde systems. Such systems will integrate both hardware and software components\cite{wolfmadsen-2000}. Embedded software are specialized hardware it runs on, which gives us some constraints when it comes to run-time, like memory usage, processessing power etc. With Internet of Things as a big trend now, these types of software has a big role today. 

One of the problems ES faces is the 

\subsection{Virtualization of embedded systems}


\subsection{Configuration management}
Configuration management er et disiplin for styring av av innhold, endringer, status på delt informasjon i et prosjekt. Det omfatter både prosesser og tekniske løsninger for å håndtere endringer og integriteten til prosjektet.F.eks hvis man utgir ny versjon av et produkt, må dokumentasjon også oppdateres. Config Management identifiserer hver komponent, og holder rede på alt som har blitt foreslått og godkjent endring fra dag 1 til slutt.

Software CM er en disiplin for kontrollering av programvaresystemer. Altså kontrollere utviklingen av store og komplekse programvarer. Noen eksempler på SCM er Git-Scm, SVN, RCS, Adele, ClearCase osv. Versjonskontroll er nøkkelen bak SCM. Følgende aspekter er med å definere CM ifølge IEEE:
-	Identification: Struktur av produktet, identifiserer komponenter og deres typer, gjør den unik og tilgjengelig på en måte.
-	Control: Kontrollerer release og og endringer av et produkt i løpet av produktets livsyklus ved å ha diverse kontroller/sjekk som sørger for konsistent produkt via "creation of a baseline product"
-	Status Accounting: Tar opp og rapporterer status til komponenter og evt endringer (forespørsler). Får også  statistikk om produktet.
-	Audit and Review: Validerer det komplette produktet og vedlikeholder konsistensen mellom komponenter ved å sørge for at produktet er en vel-definert kolleksjon av komponenter.

Kan utvides med disse tre definisjonene å:
-	Manufacture: Vedlikeholde konstruksjon og bygge produktet på en optimert måte. 
-	Process management: Passe på organisasjonens personvern, prosedyrer og livssyklus modell.
-	Teamwork: Sjekke arbeidet og passe på et godt samarbeid, og passe på interaksjonen mellom flere brukere og produktet.

shNår skal CM brukes? Det varierer. Noen velger å bruke CM system når produktet har gått gjennom utviklingsfasen og er klar for lansering/shipment. Andre velger å putte alt i CM ved oppstart av prosjektet. Begge har sine overheads. Man kan ta et valgt basert på overheads ved en endring. Er det mye manuell arbeid som å fylle ut diverse former, søke om godkjennelse osv vil man ofte plassere programverer under CM etter utvikling. Men hvis en forespørslen om en endring bruker lite tid og innsats fra utviklere, kan man velge å implementere tidlig. I teorien kan CM implementeres i alle stadiger i produktets livssyklus som opprettelse, utvikling, release, levering til kunde, bruk av produkt osv. Men ideelt sett bør et CM ha lite overhead som mulig, slik at software til CM implementeres så tidlig som mulig. Eksisterende CM systemer fokusterer dessverre på en viss fase i livsfasen, så brukere er begrenset av funksjonaliteten.



Ved å velge en robust SCM system gjør det oss mulige til å håndtere store og komplekse filmengder, støtter distribuert utvikling. En riktig kombinasjon av SCM system og "best practices" gjør det mulig for embedded development projects i å progressere raskt og effektivt.


Noen utfordringer med utvikling av embedded systemer er følgende:
-	Complex file sets
o	En embedded system består av flere komponenter, både hardware og software. Dette gjør systemet komplekst siden et slikt system kan ha mange varierte komponenter. Systemer kan også ha ulike varianter av komponenter til en spesifikk platform slik at man kan selge t produkt ved å endre ltit på krav. Å håndtere disse variantene er en stor utfordring. En annen utfordring er at produkter krever en korrekt versjon av en komponent. Å sørge for at korrelasjonen mellom hver komponent og deres avhengige filer er vedlikeholdt er en utfordring det å.
-	Distributed teams
o	Komponenter kan utvikles i ulike steder i vår verden. Samtidig kan to teams to forskjjelige steder jobbe med samme komponent, spesielt når noe outsources. Slikt samarbeid krever at utviklere har adgang til hver andres arbeid. Utfordringen er at utviklere som jobber i hvert sitt sted (geografisk) holder seg synkronisert.
-	Management and versioning of intellectual property
o	Siden embedded systemer ofte tar I bruk tredje-parts teknologier, er det viktig at de utviklerne bak disse teknologiene oppdater og vedlikeholder arbeidet sitt. Disse oppdateringene må også være sporbare slik at prosjektet inneholder riktig, kompatibel og stabil versjon av teknologien. Utfordringen er å tillate disse utviklerne å sjekke inn contributions og spore endringer i det man har kontribuert. Velge man noe open source ervel dette ikke et problem?




Når det kommer til teknisk gjeld er det ikke alltid personen som har utviklet noe som tar ansvar, men kan en annen kan ta seg av den gjelda. Mange utviklere vedlikeholder ikke sin egen kode. Mange selskaper har også regler om at når et software er ferdig utviklet av de "beste" til å bli vedlikeholdt av de nest beste, som ofte kan få mindre betalt men har mye mer arbeid å gjøre. Ingen i din organisasjonen viser interesse for det, er brukerne som må betale for gjelda. Utviklere er belønnet for hvor raskt de implementerer enn langsiktig vedlikehold og kan ha fått seg et nytt prosjekt før gjelda er betalt. Få systemer har TODO eller FIXME kommentarer i kildekoden. 

Til forskjell fra finansiell gjeld kan teknisk gjeld aldri betales tilbake i sitt fulle. Å betale TG kommer i en form av hvor lang tid det tar å fikse koden/problemet. Men det er ikke lett å vise hvilke gjeld som har høyest kost. Er interessen lavere enn hva det koster, er det ikke vits i å betale tilbake. Eksempel: Man har et system som trenger en oppgradering som kan koste 1 million. Man tar valget i å ikke oppgradere, og satse på at systemet fungerer. Det gjør det ikke, systemet går ned og firmaet taper felre millioner på å reparere systemet. Her kunne man spart penger på å oppgradere.


\subsection{Software reuse}
Use of existing software artifacts, or knowledge, to create software, is a key method for improving software quality.

\subsection{Software development life cycles} % (fold)
Weathered j-pop tube paranoid systema marketing sprawl warehouse boy receding corrupted footage DIY order-flow Chiba. Rain narrative construct shoes kanji faded bicycle denim girl. Gang car city sentient silent drugs dolphin man. Garage lights face forwards motion monofilament stimulate table sensory network disposable cartel systema sign katana. Man apophenia pre-A.I. papier-mache pistol range-rover rain computer receding hacker saturation point. 

\subsection{Software evolution} % (fold)
Soul-delay shoes neural wonton soup hotdog BASE jump knife towards A.I. engine concrete katana network bridge cartel artisanal. Rain girl shanty town advert into uplink pre-convenience store camera singularity DIY marketing Tokyo papier-mache j-pop nodal point. Fluidity hotdog camera cyber-assassin bomb 8-bit denim concrete shoes. A.I. weathered nodality corporation voodoo god industrial grade soul-delay jeans 8-bit. 

\subsection{Deployment} % (fold)
Systema beef noodles rifle papier-mache wristwatch Legba futurity city meta-Kowloon. Tattoo film otaku carbon sprawl bomb vehicle boat refrigerator San Francisco woman grenade meta-tube neural digital. Courier uplink chrome convenience store marketing Chiba refrigerator smart-modem 8-bit. Post-skyscraper claymore mine towards Kowloon hotdog savant rebar camera. Dead jeans weathered neural carbon paranoid gang A.I. nano-office papier-mache youtube 8-bit corrupted. Weathered paranoid cardboard tiger-team 3D-printed kanji man savant faded footage rebar. Man smart-denim convenience store pre-towards kanji nano-hacker soul-delay woman dome physical. 







\section{Technical debt}
Techincal debt is all about unfinished, unecessary complex, and outdated solutions which hinders us when it comes to maintencance of the solution in an effective way. 

Skjer når snarveies tar for å løse et IT-problem i stor grad fra kortsiktige hensyn til kostnad og tidsbruk. Medfører problemer ifm. Gjennomføring av endringer og nyutvikling hvis markedskravene endrer seg. Et økende globalt problem. 

Kan skapes av flere faktorer, deriblant teknologi, arbeidsprosesser (ifm utvikling), samhandling i organisasjon og mennesker (kunnskap og kapasitet).

Utviklere kan ikke bry seg pga mangel på eierskap til det som lages. Blir fortalt hva de skal gjøre, ikke med å utforme krav.

Vi ønsker å levere på tid. Spor opp den tekniske gjelden og nedbetal den før den skaper problemer.

Et stort problem idag. I 2010 lå den tekniske gjelden på 500 milliarder dollar. I 2015 vil den ligge på 1 billion dollar.

Kort tid til leveranse, alt for mye å gjøre. Levere en mindre god løsning i tide (quick and dirty), eller gjennomarbeidet løsning hvor vi går over tidsfristen. Quick and dirty gjør at vi leverer i tide, men på bekosnitng av design og kvalitet, som fører til at drift, forvaltning og vedlikeholdt blir komplekst. Å betjene teknisk gjeld kan være å vedlikeholde eksistrende kode enn å utvikle ny funksjonalitet. Det er lurt å sette opp en nedbetalingsplan som sier noe om hvordan gjelden skal nedbetales. Der kan man f.eks bruke scrum som utviklingsmetodikk hvor planen deles inn i estimerte og prioriterte oppgaver. Ikke ta opp for mye lån heller. Teknisk gjeld kan ses på som banklån ifølge Ward Cunningham. Man kan ta opp et huslån, men denne må nedbetales med renter. Å betjene TG tar masse tid. Akseptabelt å ta opp lån, men det bør være kontrollert. Ikke ta for mye lån enn det man klarer. Tenk med hodet. 

Teknisk gjeld kan forbindes med dårlig kode, men er som regel mye mer enn det. Som et vanlig lån kommer det renter med teknisk gjeld å, noe som ses på som farlig. Kostnadene man kan forbinde å ha med en gjeld. Renter kan være lavere utviklingstakt, lav konkurranseevne, dårlig sikkerhet mtp angrep utenfra, tap av utviklere og deres kompetanse, dårlig internt samarbeidsmiljø, misfornøyde kunder, tap av markedsandel. 
Skapes av fire faktorer:
-	Arbeidsprosesser
o	Utviklingsmetodikk, kan manuelle oppgaver automatiseres (deploy script f.eks), blir det skrevet tester etter feilretting, kartlegger og dokumenterer man snarveier man tar for å rekke deadline, legger man planer for håndtering av teknisk gjeld senere? Er det viktigere med ny funksjonalitet, eller håndtering av sånne ting? 
-	Mennesker (kunnskap og kapasitet)
o	Er man avhengig av enkeltpersoner? Har man de riktige personene som trengs til jobb? Blir det gitt god nok opplæring? Hva skjer når man er avhengig av noen som tar ferie, bytter prosjekt, blir sykemeldt, ut i permisjon eller pensjon? Tenk litt på det, og lag en plan på hvordan kompentasne skal bli overført. TG fører til lav motivasjon og produktivtet som igjen fører til lav effektivtet ved arbeid.
-	Teknologi
o	Er løsninger vanskelig å integrere med andre, er alle systemer kompatible med nye teknologier, finnes det utdaterte eller dupliserte koder i systemet, er systemene sikre mot angrep, løsninger gammeldags og brukervennlige, finnes det deler av systemet som er skrevet med gammel kode og vanskelig å vedlikeholde.
-	Samhandling i organisasjon
o	Kommunikasjon mellom kravstillere og utviklere, hvordan får man liste av funksjoner, er dette noe man lett skjønner, jobber vi med en backlog med oppgaver som skulle vært løst for lenge siden, men ikke er akutelle nå? 


Bruk av sekvensielle design prosesser som vannefallsmodellen for å lage store programvarer er ofte en failure. Krav spesifiseres i begynnelsen, og resten av perioden går ut på å følge disse kravene, som ikke kan endres. Lønner seg ikke når teknologi og business krav endrer seg stadig. Derfor ble agilt utviklingsmetodikk bearbeidet, handler om change and feedback. Problem med agilt: stor fokus på funksjonalitet, lite fokus på design, god kode, testing. Det fører til TG. 

Flere klassifiseringer på TG, som basert på livssyklus til prosjektfasen. Dokumentasjonsgjeld, designgjeld, kode, testing osv. 

Architecture violations might hinder future feature development as it might be hard to extend. 

------------------------------

In order to investigate the consequences of technical debt, we need to understand more formally what technical debt is, and how it occurs. When you're about to add new functionality to a system, you see two ways to do it. One is quick and dirty - you'll deliver the functionality in time but we trade off design and quality, which makes further changes harder in the future. The other way is a cleaner result, but in exhange of more time to put the functionality in place. The technical debt metaphor was first introduced by Ward Cunningham\cite{cunningham}. Like financial debt, the technical debt incurs interest payments, which come in the form of the extra effort that has to be done in future development because of bad design choices\cite{fowler}. This includes all aspects of software development lifecycle. 

\subsection{Types of technical debt}
There are many definitions of the types of technical debts that exists.


McConnels defines two categories based on how they are incurred, intentionally or unintentionally. The unintentional category includes debt that comes from doing a poor job. For instance, uninntentional debt might be when a junior software developer writes bad code due to lack of knowledge and experience. Intentional debt occurs when an organization makes a decision to optimize for the present rather than the future. An example is when the project release must be done on time, or else there wont be a next release. This leads to bad decisions, like taking a shortcut to solve a problem, and reconcile the problem after shipment

Fowlers presents a formal explanation of how techincal debt can occur. He categories technical debt into different debt types, in which he calls "Technical Debt Quadrant". As seen in the figure, the debt is grouped into four categories

Krutchen divides technical debt into two categories. Visible, debt that is visible for everyone. It containts elements such as new functionality to add and defects to fix. Invisible is the other category, debt that is only visible to software developers.



\subsection{Technical debt in Industry}

Klinger

Codabux
